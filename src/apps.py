from pycompss.api.task import task
from pycompss.api.binary import binary
from pycompss.api.constraint import constraint
from pycompss.api.parameter import FILE_IN, COLLECTION_OUT, FILE_OUT, DIRECTORY_INOUT, DIRECTORY_OUT, INOUT, IN, OUT


MASA_BINARY = "masa-openmp"

@task(returns=str)
def create_dir(dir):
     import os
     os.makedirs(dir, exist_ok=True)
     return dir

@task(work_dir=INOUT, seq1=IN, seq2=IN, alignment_file=IN, seq_dir=INOUT, returns=(str, str, str))
def prepare_for_masa(work_dir, seq1, seq2, alignment_file, seq_dir):
     import os
     seq_1_path = os.path.join(seq_dir, seq1)
     seq_2_path = os.path.join(seq_dir, seq2)
     with open(os.path.join("/scratch/cenapadrjsd/rafael.terra2/Workflow-MASAOpenMP-PAStar/src", "teste.txt"), 'w+') as f:
          f.write(seq_1_path)
          f.write("\n")
          f.write(seq_2_path)
     return seq_1_path,seq_2_path,os.path.join(work_dir, alignment_file)

@constraint(computing_units="1")
@binary(binary="masa-openmp", args="--work-dir {{work_dir}} -t {{threads}} {{input_1}} {{input_2}}")
@task(work_dir=INOUT, input_1=FILE_IN, input_2=FILE_IN)
def masa(work_dir, threads, input_1, input_2):
     """Runs the MASA binary through pycompss

     Args:
         work_dir (str): the working directory parameter
         threads (int): number of threads
         input_1 (str): name of the first fasta file
         input_2 (str): name of the second fasta file
     """
     pass

@task(pair_dir=INOUT, alignment_file = FILE_IN, returns=dict)
def get_metrics(pair_dir, alignment_file):
     """Get the metrics from a pair-wise alignment file generated by the MASA execution
     extracting the needed metadata, as Total score, Matches, Mismatches, Gap openings, and Gap extentions.

     Args:
         alignment_file (str): pair-wise alignment file generated by the MASA execution

     Returns:
         dict: dictionary contaning the metrics of the alignment file
     """
     import re, os
     metrics = dict()
     with open(alignment_file, "r") as f:
          text = f.read()
          total_score_str = re.findall(r"Total Score:\s+\d+", text)
          matches_str = re.findall(r"Matches:\s+\d+", text)
          mismatches_str = re.findall(r"Mismatches:\s+\d+", text)
          gap_openings_str = re.findall(r"Gap Openings:\s+\d+", text)
          gap_extentions_str = re.findall(r"Gap Extentions:\s+\d+", text)
          if len(total_score_str) > 0:
               metrics["total_score"] = float((total_score_str[0].split(":")[1]).strip())
          if len(matches_str) > 0:
               metrics["matches"] = float((matches_str[0].split(":")[1]).strip())
          if len(mismatches_str) > 0:
               metrics["mismatches"] = float((mismatches_str[0].split(":")[1]).strip())
          if len(gap_openings_str) > 0:
               metrics["gap_openings"] = float((gap_openings_str[0].split(":")[1]).strip())
          if len(gap_extentions_str) > 0:
               metrics["gap_extentions"] = float((gap_extentions_str[0].split(":")[1]).strip())
     return metrics

@task(multifasta_file=FILE_IN, sequence_dir=INOUT, returns=list)
def split_sequences(multifasta_file, sequence_dir):
     """Split a multifasta file into N fasta files, with one sequence each

     Args:
         multifasta_file (str): multifasta file containning the sequences

     Returns:
         dict: List of all the sequences files
     """
     from Bio import SeqIO
     import os
     records = list(SeqIO.parse(multifasta_file, "fasta"))
     record_ids = list()
     for r in records:
          seq_id = r.id[:9] if len(r.id) > 9 else r.id
          out_file = os.path.join(sequence_dir, f"{seq_id}.fasta")
          SeqIO.write(r, out_file, "fasta")
          record_ids.append(f"{seq_id}.fasta")
     return record_ids

