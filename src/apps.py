from pycompss.api.task import task
from pycompss.api.binary import binary
from pycompss.api.constraint import constraint
from pycompss.api.parameter import FILE_IN, COLLECTION_OUT, FILE_OUT, DIRECTORY_INOUT, DIRECTORY_OUT


MASA_BINARY = "masa-openmp"

@task(dir=DIRECTORY_INOUT)
def create_dir(dir):
     import os
     os.mkdir(dir)


@constraint(computing_units="1")
@binary(binary=MASA_BINARY, args = "--work-dir{{work_dir}} -t {{threads}} {{input_1}} {{input_2}}")
@task(alignment_file=FILE_OUT)
def masa(work_dir, threads, input_1, input_2, alignment_file):
     """Runs the MASA binary through pycompss

     Args:
         work_dir (str): the working directory parameter
         threads (int): number of threads
         input_1 (str): name of the first fasta file
         input_2 (str): name of the second fasta file
     """
     pass

@task(alignment_file=FILE_IN, returns=dict)
def get_metrics(alignment_file):
     """Get the metrics from a pair-wise alignment file generated by the MASA execution
     extracting the needed metadata, as Total score, Matches, Mismatches, Gap openings, and Gap extentions.

     Args:
         alignment_file (str): pair-wise alignment file generated by the MASA execution

     Returns:
         dict: dictionary contaning the metrics of the alignment file
     """
     import re
     metrics = dict()
     with open(alignment_file, "r") as f:
          total_score_str = re.findall(r"Total Score:\s+\d+")
          matches_str = re.findall(r"Matches:\s+\d+")
          mismatches_str = re.findall(r"Mismatches:\s+\d+")
          gap_openings_str = re.findall(r"Gap Openings:\s+\d+")
          gap_extentions_str = re.findall(r"Gap Extentions:\s+\d+")
          if len(total_score_str) > 0:
               metrics["total_score"] = float((total_score_str.split(":")[1]).strip())
          if len(matches_str) > 0:
               metrics["matches"] = float((matches_str.split(":")[1]).strip())
          if len(matches_str) > 0:
               metrics["mismatches"] = float((mismatches_str.split(":")[1]).strip())
          if len(matches_str) > 0:
               metrics["gap_openings"] = float((gap_openings_str.split(":")[1]).strip())
          if len(matches_str) > 0:
               metrics["gap_extentions"] = float((gap_extentions_str.split(":")[1]).strip())
     return metrics

@task(multifasta_file=FILE_IN, sequence_dir = DIRECTORY_INOUT, returns=list)
def split_sequences(multifasta_file, sequence_dir):
     """Split a multifasta file into N fasta files, with one sequence each

     Args:
         multifasta_file (str): multifasta file containning the sequences

     Returns:
         dict: List of all the sequences files
     """
     from Bio import SeqIO
     import os
     records = list(SeqIO.parse(multifasta_file, "fasta"))
     records_ids = list()
     for r in records:
          if len(r.id) > 9:
               id_ = r.id[:9]
          else:
               id_ = r.id
          SeqIO.write(r, os.path.join(sequence_dir, f"{id_}.fasta"), "fasta")
          records_ids.append(id_)
     return records_ids

