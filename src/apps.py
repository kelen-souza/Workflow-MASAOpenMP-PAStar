from pycompss.api.task import task
from pycompss.api.binary import binary
from pycompss.api.constraint import constraint
from pycompss.api.parameter import *


MASA_BINARY = "masa-openmp"

@task(returns=str)
def create_dir(dir):
     import os
     os.makedirs(dir, exist_ok=True)
     return dir

@constraint(computing_units="1")
@binary(binary="OMP_NUM_THREADS=1 masa-openmp", args="--work-dir {{work_dir}} {{input_1}} {{input_2}}")
@task(work_dir=IN, input_1=FILE_IN, input_2=FILE_IN, alignment_file= INOUT)
def masa(work_dir, input_1, input_2, alignment_file) :
     """Runs the MASA binary through pycompss

     Args:
         work_dir (str): the working directory parameter
         threads (int): number of threads
         input_1 (str): name of the first fasta file
         input_2 (str): name of the second fasta file
     """
     pass
# @task(work_dir=IN, threads=IN, input_1=FILE_IN, input_2=FILE_IN, alignment_file=FILE_OUT)
# def masa(work_dir, threads, input_1, input_2, alignment_file):
#     # Executa o binÃ¡rio
#     import subprocess
#     subprocess.run([
#         "masa-openmp",
#         "--work-dir", work_dir,
#         "-t", str(threads),
#         input_1,
#         input_2
#     ], check=True)
    
@task(pair_dir=IN, alignment_file = INOUT, returns=dict)
def get_metrics(pair_dir, alignment_file, seq1_ac, seq2_ac):
     """Get the metrics from a pair-wise alignment file generated by the MASA execution
     extracting the needed metadata, as Total score, Matches, Mismatches, Gap openings, and Gap extentions.

     Args:
         alignment_file (str): pair-wise alignment file generated by the MASA execution

     Returns:
         dict: dictionary contaning the metrics of the alignment file
     """
     import re, os
     from pathlib import Path
     from pycompss.api.api import compss_open
     metrics = dict()
     with compss_open(str(alignment_file), "r") as f:
          text = f.read()
          total_score_str = re.findall(r"Total Score:\s+\d+", text)
          matches_str = re.findall(r"Matches:\s+\d+", text)
          mismatches_str = re.findall(r"Mismatches:\s+\d+", text)
          gap_openings_str = re.findall(r"Gap Openings:\s+\d+", text)
          gap_extentions_str = re.findall(r"Gap Extentions:\s+\d+", text)
          if len(total_score_str) > 0:
               metrics["total_score"] = float((total_score_str[0].split(":")[1]).strip())
          if len(matches_str) > 0:
               metrics["matches"] = float((matches_str[0].split(":")[1]).strip())
          if len(mismatches_str) > 0:
               metrics["mismatches"] = float((mismatches_str[0].split(":")[1]).strip())
          if len(gap_openings_str) > 0:
               metrics["gap_openings"] = float((gap_openings_str[0].split(":")[1]).strip())
          if len(gap_extentions_str) > 0:
               metrics["gap_extentions"] = float((gap_extentions_str[0].split(":")[1]).strip())
          metrics["sequence_1"] = seq1_ac
          metrics["sequence_2"] = seq2_ac
     return metrics

@task(metrics=COLLECTION_IN, seq_folder=IN, max_seqs=IN, joined_sequences=FILE_OUT)
def filter_sequences(metrics, seq_folder, max_seqs, similar, joined_sequences):
     import os
     from pycompss.api.api import compss_open
     seqs_total_score = dict()
     #get the total score of the pairwise alignment
     for m in metrics:
          if seqs_total_score.get(m["sequence_1"]) is None:
               seqs_total_score[m["sequence_1"]] = list()
          if seqs_total_score.get(m["sequence_2"]) is None:
               seqs_total_score[m["sequence_2"]] = list()
          seqs_total_score[m["sequence_1"]].append(m["total_score"])
          seqs_total_score[m["sequence_2"]].append(m["total_score"])
     avg_score_seq = [(x, sum(y)/len(y)) for x, y in seqs_total_score.items()]
     score_sorted = sorted(avg_score_seq, key=lambda x: x[1], reverse=similar)
     selected = list()
     print("Score of each sequence")
     for i, j in score_sorted:
          print(f"{i}: {j}")
     if len(score_sorted) >= max_seqs:
          for i in range(0, max_seqs):
               selected.append(score_sorted[i][0])
     else:
          selected = [x[0] for x in score_sorted]
     text_seqs = ""
     for s in selected:
          with open(os.path.join(seq_folder, s), "r") as file_:
               text = file_.read()
               text_seqs += text
     with compss_open(joined_sequences, "w+") as file_:
          file_.write(text_seqs)
     return joined_sequences


@task(multifasta_file=FILE_IN, sequence_dir=IN, returns=list)
def split_sequences(multifasta_file, sequence_dir):
     """Split a multifasta file into N fasta files, with one sequence each

     Args:
         multifasta_file (str): multifasta file containning the sequences

     Returns:
         dict: List of all the sequences files
     """
     from Bio import SeqIO
     import os
     records = list(SeqIO.parse(multifasta_file, "fasta"))
     record_ids = list()
     for r in records:
          if len(r.id) > 8:
               seq_id = r.id[:8]
          else:
               seq_id = r.id
          out_file = os.path.join(sequence_dir, f"{seq_id}.fasta")
          SeqIO.write(r, out_file, "fasta")
          record_ids.append(f"{seq_id}.fasta")
     return record_ids


#@constraint(computing_units="1")
@binary(binary="msa_pastar", args="-f {{output}} -t {{threads}} {{input_}}")
@task(output=FILE_OUT, threads = IN, input_=FILE_IN)
def pastar(output, threads, input_):
     pass