import re
import os
import glob
import sys
from pathlib import Path


def get_metrics(pair_dir, alignment_file, seq1_ac, seq2_ac):
    """Get the metrics from a pair-wise alignment file generated by the MASA execution
    extracting the needed metadata, as Total score, Matches, Mismatches, Gap openings, and Gap extentions.

    Args:
        alignment_file (str): pair-wise alignment file generated by the MASA execution

    Returns:
        dict: dictionary contaning the metrics of the alignment file
    """
    metrics = dict()
    with open(str(alignment_file), "r") as f:
        text = f.read()
        total_score_str = re.findall(r"Total Score:\s+\d+", text)
        matches_str = re.findall(r"Matches:\s+\d+", text)
        mismatches_str = re.findall(r"Mismatches:\s+\d+", text)
        gap_openings_str = re.findall(r"Gap Openings:\s+\d+", text)
        gap_extentions_str = re.findall(r"Gap Extentions:\s+\d+", text)
        if len(total_score_str) > 0:
            metrics["total_score"] = float(
                (total_score_str[0].split(":")[1]).strip())
        if len(matches_str) > 0:
            metrics["matches"] = float((matches_str[0].split(":")[1]).strip())
        if len(mismatches_str) > 0:
            metrics["mismatches"] = float(
                (mismatches_str[0].split(":")[1]).strip())
        if len(gap_openings_str) > 0:
            metrics["gap_openings"] = float(
                (gap_openings_str[0].split(":")[1]).strip())
        if len(gap_extentions_str) > 0:
            metrics["gap_extentions"] = float(
                (gap_extentions_str[0].split(":")[1]).strip())
        metrics["sequence_1"] = seq1_ac
        metrics["sequence_2"] = seq2_ac
    return metrics


def filter_sequences(metrics, seq_folder, max_seqs, similar, joined_sequences):
    seqs_total_score = dict()
    # get the total score of the pairwise alignment
    for m in metrics:
        if seqs_total_score.get(m["sequence_1"]) is None:
            seqs_total_score[m["sequence_1"]] = list()
        if seqs_total_score.get(m["sequence_2"]) is None:
            seqs_total_score[m["sequence_2"]] = list()
        seqs_total_score[m["sequence_1"]].append(m["total_score"])
        seqs_total_score[m["sequence_2"]].append(m["total_score"])
    avg_score_seq = [(x, sum(y)/len(y)) for x, y in seqs_total_score.items()]
    score_sorted = sorted(avg_score_seq, key=lambda x: x[1], reverse=similar)
    selected = list()
    print("Score of each sequence")
    for i, j in score_sorted:
        print(f"{i}: {j}")
    if len(score_sorted) >= max_seqs:
        for i in range(0, max_seqs):
            selected.append(score_sorted[i][0])
    else:
        selected = [x[0] for x in score_sorted]
    text_seqs = ""
    for s in selected:
        with open(os.path.join(seq_folder, s), "r") as file_:
            text = file_.read()
            text_seqs += text
    with open(joined_sequences, "w+") as file_:
        file_.write(text_seqs)
    return joined_sequences


if __name__ == "__main__":
    if len(sys.argv) <= 5:
        print('argumentos insuficientes')
        sys.exit()
    pairs_dir = sys.argv[1]
    sequences_dir = sys.argv[2]
    if sys.argv[3] == '0':
        similar = False
    else:
        similar = True
    max_seqs = int(sys.argv[4])
    joined_sequences = sys.argv[5]
    files = glob.glob(os.path.join(pairs_dir, "*"))
    metrics = list()
    for f in files:
        seq = f.split('/')[-1]
        seqs = seq.split('_')
        metrics.append(get_metrics(f, os.path.join(f, "alignment.00.txt"), seqs[0] + ".fasta", seqs[1] + ".fasta"))
    filter_sequences(metrics, sequences_dir, max_seqs, similar, joined_sequences)
